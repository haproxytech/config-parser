// Code generated by go generate; DO NOT EDIT.
/*
Copyright 2019 HAProxy Technologies

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tests

import (
	"fmt"
	"strings"
	"testing"

	"github.com/haproxytech/config-parser/v2/parsers/tcp"
)

func TestRequeststcp(t *testing.T) {
	tests := map[string]bool{
		"tcp-request content accept": true,
		"tcp-request content accept if !HTTP": true,
		"tcp-request content reject": true,
		"tcp-request content reject if !HTTP": true,
		"tcp-request content capture req.payload(0,6) len 6": true,
		"tcp-request content capture req.payload(0,6) len 6 if !HTTP": true,
		"tcp-request content set-priority-class int(1)": true,
		"tcp-request content set-priority-class int(1) if some_check": true,
		"tcp-request content set-priority-offset int(10)": true,
		"tcp-request content set-priority-offset int(10) if some_check": true,
		"tcp-request content track-sc0 src": true,
		"tcp-request content track-sc0 src if some_check": true,
		"tcp-request content track-sc1 src": true,
		"tcp-request content track-sc1 src if some_check": true,
		"tcp-request content track-sc2 src": true,
		"tcp-request content track-sc2 src if some_check": true,
		"tcp-request content set-dst ipv4(10.0.0.1)": true,
		"tcp-request content set-var(sess.src) src": true,
		"tcp-request content set-var(sess.dn) ssl_c_s_dn": true,
		"tcp-request content unset-var(sess.src)": true,
		"tcp-request content unset-var(sess.dn)": true,
		"tcp-request content silent-drop": true,
		"tcp-request content silent-drop if !HTTP": true,
		"tcp-request content send-spoe-group engine group": true,
		"tcp-request content use-service lua.deny": true,
		"tcp-request content use-service lua.deny if !HTTP": true,
		"tcp-request connection accept": true,
		"tcp-request connection accept if !HTTP": true,
		"tcp-request connection reject": true,
		"tcp-request connection reject if !HTTP": true,
		"tcp-request connection expect-proxy layer4 if { src -f proxies.lst }": true,
		"tcp-request connection expect-netscaler-cip layer4": true,
		"tcp-request connection capture req.payload(0,6) len 6": true,
		"tcp-request connection track-sc0 src": true,
		"tcp-request connection track-sc0 src if some_check": true,
		"tcp-request connection track-sc1 src": true,
		"tcp-request connection track-sc1 src if some_check": true,
		"tcp-request connection track-sc2 src": true,
		"tcp-request connection track-sc2 src if some_check": true,
		"tcp-request connection sc-inc-gpc0(2)": true,
		"tcp-request connection sc-inc-gpc0(2) if is-error": true,
		"tcp-request connection sc-inc-gpc1(2)": true,
		"tcp-request connection sc-inc-gpc1(2) if is-error": true,
		"tcp-request connection sc-set-gpt0(0) 1337": true,
		"tcp-request connection sc-set-gpt0(0) 1337 if exceeds_limit": true,
		"tcp-request connection set-src src,ipmask(24)": true,
		"tcp-request connection set-src src,ipmask(24) if some_check": true,
		"tcp-request connection set-src hdr(x-forwarded-for)": true,
		"tcp-request connection set-src hdr(x-forwarded-for) if some_check": true,
		"tcp-request session accept": true,
		"tcp-request session accept if !HTTP": true,
		"tcp-request session reject": true,
		"tcp-request session reject if !HTTP": true,
		"tcp-request session track-sc0 src": true,
		"tcp-request session track-sc0 src if some_check": true,
		"tcp-request session track-sc1 src": true,
		"tcp-request session track-sc1 src if some_check": true,
		"tcp-request session track-sc2 src": true,
		"tcp-request session track-sc2 src if some_check": true,
		"tcp-request session sc-inc-gpc0(2)": true,
		"tcp-request session sc-inc-gpc0(2) if is-error": true,
		"tcp-request session sc-inc-gpc1(2)": true,
		"tcp-request session sc-inc-gpc1(2) if is-error": true,
		"tcp-request session sc-set-gpt0(0) 1337": true,
		"tcp-request session sc-set-gpt0(0) 1337 if exceeds_limit": true,
		"tcp-request session set-var(sess.src) src": true,
		"tcp-request session set-var(sess.dn) ssl_c_s_dn": true,
		"tcp-request session unset-var(sess.src)": true,
		"tcp-request session unset-var(sess.dn)": true,
		"tcp-request session silent-drop": true,
		"tcp-request session silent-drop if !HTTP": true,
		"tcp-request": false,
		"tcp-request content": false,
		"tcp-request connection": false,
		"tcp-request session": false,
		"---": false,
		"--- ---": false,
	}
	parser := &tcp.Requests{}
	for command, shouldPass := range tests {
		t.Run(command, func(t *testing.T) {
			line := strings.TrimSpace(command)
			err := ProcessLine(line, parser)
			if shouldPass {
				if err != nil {
					t.Errorf(err.Error())
					return
				}
				result, err := parser.Result()
				if err != nil {
					t.Errorf(err.Error())
					return
				}
				var returnLine string
				if result[0].Comment == "" {
					returnLine = result[0].Data
				} else {
					returnLine = fmt.Sprintf("%s # %s", result[0].Data, result[0].Comment)
				}
				if line != returnLine {
					t.Errorf(fmt.Sprintf("error: has [%s] expects [%s]", returnLine, line))
				}
			} else {
				if err == nil {
					t.Errorf(fmt.Sprintf("error: did not throw error for line [%s]", line))
				}
				_, parseErr := parser.Result()
				if parseErr == nil {
					t.Errorf(fmt.Sprintf("error: did not throw error on result for line [%s]", line))
				}
			}
		})
	}
}
